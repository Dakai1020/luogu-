# p3392

## 题目描述
    某国法律规定，只要一个由 N \times MN×M 个小方块组成的旗帜符合如下规则，就是合法的国旗。（毛熊：阿嚏——）
    从最上方若干行（至少一行）的格子全部是白色的；
    接下来若干行（至少一行）的格子全部是蓝色的；
    剩下的行（至少一行）全部是红色的；
    现有一个棋盘状的布，分成了 NN 行 MM 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成该国国旗，方法是在一些格子上涂颜料，盖住之前的颜色。
    小a很懒，希望涂最少的格子，使这块布成为一个合法的国旗。

## 思路

### 1. 暴力枚举边界

```C++
/*
 * p3392
 */
#include <cstdio>
#include<bitset>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include  <algorithm>

using namespace std;
const int N = 51, M = 51;
int n, m, ans= 0, mi = 9999;
char c[N][N];

int main() {
    cin >> n >> m;
    int k, g, i, j;
    // 赋值
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= m; j++)
            cin >> c[i][j];
    }

    //枚举边界
    for (i = 1; i <= n - 2; ++i) {
        for (j = i + 1; j <= n - 1; j++) {
            /*
             * 此处提交错误
             * 原因： 每次 ans 都要初始化
             */
            ans = 0;

            for (k = 1; k <= i; k++)
                for (g = 1; g <= m; g++) if (c[k][g] != 'W') ans++;
            for (k = i + 1; k <= j; k++)
                for (g = 1; g <= m; g++) if (c[k][g] != 'B') ans++;
            for (k = j + 1; k <= n; k++)
                for (g = 1; g <= m; g++) if (c[k][g] != 'R') ans++;
            mi = min(ans, mi);
        }
    }

    cout << mi;
    return 0;


}

```