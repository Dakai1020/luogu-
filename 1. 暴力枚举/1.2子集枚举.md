# 1.2 子集枚举

---

# 题目一 P1036 [NOIP2002 普及组] 选数

## 1. 涉及知识点
* 子集枚举 思路
    用 a[30] 数组存储每个元素，用 U-1 表述全集(二进制代码，对每个集合进行编码)，   在分析子集和全集的关系时，可以用与或运算和异或运算。
    （在c++中没有直接表示二进制数的方法，使用左移位）
    例子：
    若一个集合包含n个元素，那么可以用n位二进制代码表示这个全集
    设n = 5，那么一共有5个元素，在全集中每个元素有两种可能(存在或不存在)，则有 00000 – 11111 的集合表示
    仅包含第i个元素的集合 ： 1 << ( i - 1)
    并集： A2 or A3
    交集： a3 = a1 & a4
    集合包含关系（判断A1包含A2）： ((a1 | a2) == a1 && (a1&a2) ==a2) 
    元素和集合的属于关系： 1<<(i-1) & a1
    补集（和全集的异或关系）： a1 ^ a
## 2. code
```
01:	#include <cstdio>
02:	#include<bitset>
03:	#include <stdio.h>
04:	#include <string.h>
05:	#include <iostream>
06:	#include <iostream>
07:	using namespace std;
08:	/*
09:	 * 子集枚举 思路
10:	 * 1 用 a[30] 数组存储每个元素
11:	 * 2 用 U-1 表述全集(二进制代码，对每个集合进行编码)
12:	 */
13:	int a[30]; //表示每个元素
14:	
15:	/*
16:	 * check 质数
17:	 */
18:	bool check(int x) {
19:	    for (int i = 2; i * i <= x; ++i) {
20:	        if (x % i == 0) return 0;
21:	    }
22:	    return 1;
23:	}
24:	
25:	int main() {
26:	    int n, k, ans = 0;
27:	    /* n: 整数数量   k: 选取整数个数*/
28:	    cin >> n >> k; //先赋值n，再赋值k
29:	    for (int i = 0; i < n; ++i) {
30:	        scanf("%d", &a[i]);
31:	    }
32:	    int U = 1 << n; //z左移位->二进制数表示集合
33:	    /*子集枚举： 对每个集合枚举*/
34:	    for (int S = 0; S < U; S++) {
35:	        if (__builtin_popcount(S) == k) {  //找到 k元子集合
36:	            int sum = 0;
37:	            for (int i = 0; i < n; ++i)
38:	                if (S & (1 << i))
39:	                    sum += a[i]; /*  第i个元素的左移位 1<<i 为 (1000...)b,和 S集合与运算，S集合的 第 i 位 如果为 1 则return 1     */
40:	            if (check(sum)) ans++;
41:	
42:	        }
43:	    }
44:	    cout << ans;
45:	    return 0;
46:	}

```

# 题目二 p1157 组合数的输出
## 题目描述

排列与组合是常用的数学方法，其中组合就是从nn个元素中抽出rr个元素(不分顺序且r \le n)r≤n)，我们可以简单地将nn个元素理解为自然数1,2,…,n1,2,…,n，从中任取rr个数。

现要求你输出所有组合。

例如n=5,r=3n=5,r=3，所有组合为：

12 3 , 1 2 4 , 1 2 5 , 1 3 4 ,1 3 5 , 1 4 5 , 2 3 4 , 2 3 5 , 2 4 5 , 3 4 5123,124,125,134,135,145,234,235,245,345

## 输入格式

一行两个自然数n,r(1<n<21,0 \le r \le n)n,r(1<n<21,0≤r≤n)。

输出格式
所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，所有的组合也按字典顺序。

**注意哦!输出时，每个数字需要33个场宽，pascal可以这样：

write(ans:3);

+ 根据题目要求从小到大输出，则要让 10110 出现在 10101的前面，因为第四个1表示第4个数是否包包含在集合中

```

#include <cstdio>
#include<bitset>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <iostream>
using namespace std;
int a[30];

int main(){
    int n,r;
    cin >> n >>r;
    for(int S = (1<<n)-1; S >= 0; S --) { //从全集枚举到0，让10110 早于 10101 出现， 符合字典序题目要求
        int cnt = 0;

        for(int i = 0; i < n; i ++){
            if(S  & (1 << i))
                a[cnt++] = i;
        }
        if(cnt == r){
            for (int i = r - 1; i >= 0 ; i--) {
                printf("%3d", n - a[i]);
            }
            puts(" ");
        }

    }
    return 0;
}
```
